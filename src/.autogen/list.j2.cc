#include "cdada/list.h"
#include "cdada/__common_internal.h"
#include "cdada/__list_internal.h"

#include <stdlib.h>
#include <string.h>

//DO NOT EDIT: Autogenerated with gen-srcs

using namespace std;

cdada_list_t* __cdada_list_create(const uint16_t val_size,
						__cdada_list_ops_t* ops){

	__cdada_list_int_t* m = NULL;

	if(unlikely(val_size == 0))
		return m;

	m = (__cdada_list_int_t*)malloc(sizeof(__cdada_list_int_t));
	memset(m, 0, sizeof(__cdada_list_int_t));
	m->magic_num = CDADA_MAGIC;
	m->user_val_len = val_size;

	try{
		//Custom type
		if(ops){
			m->val_len = m->user_val_len = val_size;
			m->ops = ops;
			(*m->ops->create)(m);
			return m;
		}
{{ "" }}
		//Regular
		{%for t in types %}
			{%- if not loop.first -%}else {% endif -%}
			if(	{%- if t[2] < 3 -%}
					val_size == {{t[2]}}
				{%- else -%}
					val_size > {{ loop.previtem[2] }} && val_size <= {{ t[2] }}
				{%- endif -%}
			){
			m->list.{{t[0]}} = new list<{{t[1]}}>();
			m->val_len = {{t[2]}};
		}
		{%-endfor -%}
		else{
			//Unsupported; use custom type
			goto ROLLBACK;
		}
	}catch(bad_alloc& e){
		goto ROLLBACK;
	}catch(...){
		CDADA_ASSERT(0);
		goto ROLLBACK;
	}

	return m;

ROLLBACK:
	free(m);
	return NULL;
}

/**
* Destroy a list structure
*/
int cdada_list_destroy(cdada_list_t* list){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				delete m->list.{{t[0]}};
				break;
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				(*m->ops->destroy)(m);
				break;
			default:
				CDADA_ASSERT(0);
				return CDADA_E_UNKNOWN;
		}
	}catch(...){
		CDADA_ASSERT(0);
		return CDADA_E_UNKNOWN;
	}

	m->magic_num = 0x0;
	free(m);

	return CDADA_SUCCESS;
}

int cdada_list_clear(cdada_list_t* list){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				m->list.{{t[0]}}->clear();
				break;
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				(*m->ops->clear)(m);
				break;
			default:
				CDADA_ASSERT(0);
				return CDADA_E_UNKNOWN;
		}
	}catch(bad_alloc& e){
		return CDADA_E_MEM;
	}catch(...){
		CDADA_ASSERT(0);
		return CDADA_E_UNKNOWN;
	}

	return CDADA_SUCCESS;
}

bool cdada_list_empty(const cdada_list_t* list){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	if(unlikely(!m || m->magic_num != CDADA_MAGIC))
		return false;

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				return m->list.{{t[0]}}->empty();
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				return (*m->ops->empty)(m);
			default:
				break;
		}
	}catch(...){}

	CDADA_ASSERT(0);
	return false;
}

uint32_t cdada_list_size(const cdada_list_t* list){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	if(unlikely(!m || m->magic_num != CDADA_MAGIC))
		return 0;

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				return m->list.{{t[0]}}->size();
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				return (*m->ops->size)(m);
			default:
				break;
		}
	}catch(...){}

	CDADA_ASSERT(0);
	return 0;
}

int cdada_list_insert(cdada_list_t* list, const void* val, const uint32_t pos){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	if(unlikely(!val))
		return CDADA_E_INVALID;

	//NOTE: we don't want std::list insert "replace semantics", so we return
	//E_EXISTS if val is present in the list
	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				return cdada_list_insert_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								val, pos);
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				return (*m->ops->insert)(m, val, pos);
			default:
				break;
		}
	}catch(bad_alloc& e){
		return CDADA_E_MEM;
	}catch(...){}

	CDADA_ASSERT(0);
	return CDADA_E_UNKNOWN;
}

int cdada_list_get(const cdada_list_t* list, const uint32_t pos, void* val){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	if(unlikely(!val))
		return CDADA_E_INVALID;

	//NOTE: we don't want std::list insert "replace semantics", so we return
	//E_EXISTS if val is present in the list
	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				return cdada_list_get_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								pos, val);
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				return (*m->ops->get)(m, pos, val);
			default:
				break;
		}
	}catch(bad_alloc& e){
		return CDADA_E_MEM;
	}catch(...){}

	CDADA_ASSERT(0);
	return CDADA_E_UNKNOWN;
}

static int __cdada_list_first_last(const cdada_list_t* list, bool first,
								void* key){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	if(unlikely(!m || m->magic_num != CDADA_MAGIC || !key))
		return false;

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				return cdada_list_first_last_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								first, key);
		{%-endfor %}
			case 0:
				return (*m->ops->first_last)(m, first, key);
			default:
				break;
		}
	}catch(...){}

	CDADA_ASSERT(0);
	return false;
}

int cdada_list_first(const cdada_list_t* list, void* key){
	return __cdada_list_first_last(list, true, key);
}

int cdada_list_last(const cdada_list_t* list, void* key){
	return __cdada_list_first_last(list, false, key);
}

int cdada_list_erase(cdada_list_t* list, const uint32_t pos){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				return cdada_list_erase_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								pos);
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				return (*m->ops->erase)(m, pos);
			default:
				break;
		}
	}catch(bad_alloc& e){
		return CDADA_E_MEM;
	}catch(...){}

	CDADA_ASSERT(0);
	return CDADA_E_UNKNOWN;
}

int cdada_list_remove(cdada_list_t* list, const void* val){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	if(unlikely(!val))
		return CDADA_E_INVALID;

	//NOTE: we don't want std::list remove "replace semantics", so we return
	//E_EXISTS if val is present in the list
	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				return cdada_list_remove_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								val);
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				return (*m->ops->remove)(m, val);
			default:
				break;
		}
	}catch(bad_alloc& e){
		return CDADA_E_MEM;
	}catch(...){}

	CDADA_ASSERT(0);
	return CDADA_E_UNKNOWN;
}

static int cdada_list_push_(cdada_list_t* list, const void* val, bool front){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	if(unlikely(!val))
		return CDADA_E_INVALID;

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				return cdada_list_push_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								val, front);
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				return (*m->ops->push)(m, val, front);
			default:
				break;
		}
	}catch(bad_alloc& e){
		return CDADA_E_MEM;
	}catch(...){}

	CDADA_ASSERT(0);
	return CDADA_E_UNKNOWN;
}

int cdada_list_push_front(cdada_list_t* list, const void* val){
	return cdada_list_push_(list, val, true);
}

int cdada_list_push_back(cdada_list_t* list, const void* val){
	return cdada_list_push_(list, val, false);
}

static int cdada_list_pop_(cdada_list_t* list, bool front){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				return cdada_list_pop_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								front);
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				return (*m->ops->pop)(m, front);
			default:
				break;
		}
	}catch(bad_alloc& e){
		return CDADA_E_MEM;
	}catch(...){}

	CDADA_ASSERT(0);
	return CDADA_E_UNKNOWN;
}

int cdada_list_pop_front(cdada_list_t* list){
	return cdada_list_pop_(list, true);
}

int cdada_list_pop_back(cdada_list_t* list){
	return cdada_list_pop_(list, false);
}

int cdada_list_sort(cdada_list_t* list){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	if(unlikely(!m || m->magic_num != CDADA_MAGIC))
		return CDADA_E_INVALID;

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				m->list.{{t[0]}}->sort();
				break;
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				(*m->ops->sort)(m);
				break;
			default:
				CDADA_ASSERT(0);
				return CDADA_E_UNKNOWN;
		}
	}catch(...){
		CDADA_ASSERT(0);
		return CDADA_E_UNKNOWN;
	}

	return CDADA_SUCCESS;
}

int cdada_list_reverse(cdada_list_t* list){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	if(unlikely(!m || m->magic_num != CDADA_MAGIC))
		return CDADA_E_INVALID;

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				m->list.{{t[0]}}->reverse();
				break;
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				(*m->ops->reverse)(m);
				break;
			default:
				CDADA_ASSERT(0);
				return CDADA_E_UNKNOWN;
		}
	}catch(...){
		CDADA_ASSERT(0);
		return CDADA_E_UNKNOWN;
	}

	return CDADA_SUCCESS;
}

int cdada_list_unique(cdada_list_t* list){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	if(unlikely(!m || m->magic_num != CDADA_MAGIC))
		return CDADA_E_INVALID;

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				m->list.{{t[0]}}->unique();
				break;
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				(*m->ops->unique)(m);
				break;
			default:
				CDADA_ASSERT(0);
				return CDADA_E_UNKNOWN;
		}
	}catch(...){
		CDADA_ASSERT(0);
		return CDADA_E_UNKNOWN;
	}

	return CDADA_SUCCESS;
}

int cdada_list_traverse(const cdada_list_t* list, cdada_list_it f,
								void* opaque){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	if(unlikely(!f))
		return CDADA_E_INVALID;

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				cdada_list_traverse_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								f, opaque);
				break;
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				(*m->ops->traverse)(m, f, opaque);
				break;
			default:
				CDADA_ASSERT(0);
				return CDADA_E_UNKNOWN;
		}
	}catch(...){
		CDADA_ASSERT(0);
		return CDADA_E_UNKNOWN;
	}

	return CDADA_SUCCESS;
}

int cdada_list_rtraverse(const cdada_list_t* list, cdada_list_it f,
								void* opaque){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;

	CDADA_CHECK_MAGIC(m);

	if(unlikely(!f))
		return CDADA_E_INVALID;

	try{
		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				cdada_list_rtraverse_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								f, opaque);
				break;
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				(*m->ops->rtraverse)(m, f, opaque);
				break;
			default:
				CDADA_ASSERT(0);
				return CDADA_E_UNKNOWN;
		}
	}catch(...){
		CDADA_ASSERT(0);
		return CDADA_E_UNKNOWN;
	}

	return CDADA_SUCCESS;
}

int cdada_list_dump(cdada_list_t* list, uint32_t size, char* buffer,
							uint32_t* size_used){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;
	CDADA_CHECK_MAGIC(m);

	if(!size_used || (buffer&&size ==0))
		return CDADA_E_INVALID;

	try{
		std::stringstream ss;
		ss << "{";

		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				cdada_list_dump_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								ss);
				break;
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				(*m->ops->dump)(m, ss);
				break;
			default:
				CDADA_ASSERT(0);
				return CDADA_E_UNKNOWN;
		}

		ss << "}";

		*size_used = ss.str().length()+1;
		if(!buffer)
			return CDADA_SUCCESS;

		snprintf(buffer, size, "%s", ss.str().c_str());
		if(ss.str().length()+1 > size)
			return CDADA_E_INCOMPLETE;
	}catch(bad_alloc& e){
		return CDADA_E_MEM;
	}catch(...){
		CDADA_ASSERT(0);
		return CDADA_E_UNKNOWN;
	}

	return CDADA_SUCCESS;
}

int cdada_list_print(cdada_list_t* list, FILE *stream){

	__cdada_list_int_t* m = (__cdada_list_int_t*)list;
	CDADA_CHECK_MAGIC(m);

	try{
		std::stringstream ss;
		ss << "{";

		int c = m->ops? 0 : m->val_len;
		switch(c){
		{%-for t in types %}
			case {{t[2]}}:
				cdada_list_dump_u<{{t[1]}}>(m,
								m->list.{{t[0]}},
								ss);
				break;
		{%-endfor %}
			case 0:
				CDADA_ASSERT(m->ops);
				(*m->ops->dump)(m, ss);
				break;
			default:
				CDADA_ASSERT(0);
				return CDADA_E_UNKNOWN;
		}
		ss << "}\n";

		fprintf(stream, "%s", ss.str().c_str());
	}catch(bad_alloc& e){
		return CDADA_E_MEM;
	}catch(...){
		CDADA_ASSERT(0);
		return CDADA_E_UNKNOWN;
	}

	return CDADA_SUCCESS;
}
